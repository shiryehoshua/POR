
Simple case:
t0 = new_thread () {	t1 = new_thread () {	t2 = new_thread () {	t3 = new_thread () {
  wait (t1);		  h = create_image (H)	  e = create_image (E)	  y = create_image (Y)
  print_image (h);	}			}
  wait (t2);
  print_image (e);
  wait (t3);
  print_image (y);
}

Shared variables:
// thread_var means that array is a synchronized variable, that can only be written to when the thread has access appropriate access.
struct image array[3];
struct thread_var thread_array = create_thread_var (&array);
struct thread * t0, t1, t2, t3;

t0 = new_thread () {					t1 = new_thread () {				t2 = new_thread () {				t3 = new_thread () {
  wait (t1);						  array.safe_write (0, create_image (H));	  array.safe_write (1, create_image (E));	  array[2] = create_image (Y)
  print_image (safe_read (0, thread_array);		}						}						}
  wait (t2);
  print_image (safe_read (1, thread_array);
  wait (t3);
  print_image (safe_read (2, thread_array);
}


n=12 threads:
struct image array[12];
struct thread_var thread_array = create_thread_var (&array);
struct thread * t0;
struct nthread *t;
int i;

							// Creates 12 new threads
t0 = new_thread () {					t = new_thread (12, &i) {			
  for (struct thread * ti : t->list_threads) {		  array.safe_write (i, create_image (ALPHABET[i]));	
    wait (ti);		}					
    print_image (safe_read (ti->index, thread_array);
}

/* Rough implementation of thread_var. */
struct thread_var {
  void * variable;
  struct lock;
}

struct thread_var * create_thread_var (void * var);
bool safe_read (size_t offset, struct thread_var *var);
bool safe_write (size_t offset, struct thread_var *var);


